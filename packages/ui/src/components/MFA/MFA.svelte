<script lang="ts">
	import Button from '../Button/Button.svelte';
	import Icon from '@iconify/svelte';
	import Input from '../Input/Input.svelte';
	import { VerifyCode } from 'validation-schemas';
	import { superForm } from 'sveltekit-superforms/client';
	import { Dropdown, Radio } from 'flowbite-svelte';
	import { page } from '$app/stores';
	import { goto } from '$app/navigation';
	import { zod } from 'sveltekit-superforms/adapters';
	import StexsClient from 'stexs-client';
	import { setToast } from '../../utils/toast';

	interface Props {
		cancel: () => void;
		confirm: (
			code: string,
			type: string,
		) => Promise<Array<{ message: string }> | void>;
		stexs: StexsClient;
		types: string[];
		type?: string;
		confirmErrors?: { message: string }[];
	}

	let {
		cancel,
		confirm,
		stexs,
		types,
		type = $bindable(),
		confirmErrors = []
	}: Props = $props();

	type = types.length == 1 ? types[0] : '_selection';

	let submitted: boolean = $state(false);
	let requested: boolean = $state(false);
	let codeInput: HTMLInputElement = $state();
	let formData = $state({
		code: ''
	});
	let codeRequested: { [key: string]: boolean } = $state({
		email: false,
	});

	type MFAMethod = {
		icon: string;
		title: string;
	}

	const descriptions: { [key: string]: string } = {
		_selection: 'Select an authentication method.',
		totp: 'Enter the code generated by your authenticator app to proceed.',
		email: 'Enter the code sent to your email address to proceed.',
	};
	const choices: Record<string, MFAMethod> = {
		totp: {
			icon: 'arcticons:otp-authenticator',
			title: 'Authenticator App',
		},
		email: {
			icon: 'material-symbols-light:mark-email-unread-outline',
			title: 'Email',
		},
	};
	const requestCodeTypes = ['email'];

	const { form, errors, validateForm } = superForm(formData, {
		dataType: 'json',
		validators: zod(VerifyCode),
		validationMethod: 'oninput',
		clearOnSubmit: 'none',
	});

	async function requestNewCode(type: string, showMessage: boolean = false) {
		if (!codeRequested[type]) codeRequested[type] = true;

		const response = await (await stexs.auth.mfa.requestCode(type)).json();

		requested = false;

		if (response.success && showMessage) {
			setToast({
				title: 'Success',
				type: 'success',
				description: 'New authentification code successfully requested.',
				duration: 5000
			});

			return;
		}

		page

		if (response.errors) {
			const invalidToken = response.errors
				.map((error) => error.code)
				.includes('INVALID_TOKEN');

			if ($page.url.pathname === '/sign-in-confirm' && invalidToken) {
				setToast({
					title: 'Error',
					type: 'error',
					description: 'Your session has expired. Please sign in again.',
					duration: 5000
				});

				goto('/sign-in');
			}

			response.errors.forEach((error: { message: string }) => {
				$errors._errors === undefined
					? ($errors._errors = [error.message])
					: $errors._errors.push(error.message);
			});
		}
	}

	async function confirmCode(event) {
		event.preventDefault();

		const result = await validateForm();

		if (!result.valid) return;

		submitted = true;

		const resultErrors = await confirm($form.code, type);

		if (resultErrors) {
			resultErrors.forEach((error: { message: string }) => {
				$errors._errors === undefined
					? ($errors._errors = [error.message])
					: $errors._errors.push(error.message);
				return;
			});
		}

		confirmErrors.forEach((error: { message: string }) => {
			$errors._errors === undefined
				? ($errors._errors = [error.message])
				: $errors._errors.push(error.message);
			return;
		});

		submitted = false;
	}

	$effect(() => {
		if (type !== '_selection' && codeInput) codeInput.focus();
	});

	$effect(() => {
		const upperCasedCode = $form.code.toUpperCase();

		if ($form.code !== upperCasedCode) {
			$form.code = upperCasedCode;
		}
	});
</script>

<div class="card p-5 space-y-6">
	<div class="m-auto">
		<h3 class="h3 text-primary-500 text-center">Multi-Factor Authentication</h3>
		<div class="mt-3 m-auto max-w-[280px] text-center">
			{#if type === '_selection'}
				{descriptions._selection}
			{:else}
				{descriptions[type]}
			{/if}
		</div>
	</div>
	{#if type === '_selection'}
		<div class="flex flex-col space-y-2">
			{#each types as currentType}
				<Button
					onclick={async () => {
						type = currentType;
						requestCodeTypes.includes(type) &&
							(await requestNewCode(currentType));
					}}
					class="flex variant-ringed-surface p-2 rounded-md hover:bg-surface-600 transition items-center space-x-2 justify-start"
				>
					<span class="badge variant-filled-primary">
						<Icon icon={choices[currentType].icon} class="text-[24px]" />
					</span>
					<p>{choices[currentType].title}</p>
				</Button>
			{/each}
		</div>
		<Button
			class="variant-ringed-surface hover:bg-surface-600"
			value="Cancel"
			onclick={cancel}>Cancel</Button
		>
	{:else if type}
		<div class="flex flex-row space-x-2 justify-center">
			{#if types && types.length > 1}
				<Button class="p-2 variant-ghost-surface">
					<span class="badge variant-filled-primary rounded">
						<Icon icon={choices[type].icon} class="text-[24px]" />
					</span>
					<p>{choices[type].title}</p>
					<Icon icon="iconamoon:arrow-down-2-duotone" class="text-[24px]" />
				</Button>
				<Dropdown
					class="bg-surface-800 rounded-md p-2 space-y-2 border border-surface-500"
				>
					{#each types as currentType}
						<Radio
							bind:group={type}
							onclick={() => {
								if (
									!codeRequested[currentType] &&
									requestCodeTypes.includes(currentType)
								) {
									requestNewCode(currentType);
								}
							}}
							value={currentType}
							custom
						>
							<div
								class="flex justify-start cursor-pointer variant-ghost-surface p-2 rounded-md hover:bg-surface-500 peer-checked:bg-surface-500 peer-checked:cursor-default transition w-full items-center"
							>
								<span class="badge variant-filled-primary rounded">
									<Icon icon={choices[currentType].icon} class="text-[24px]" />
								</span>
								<p class="ml-2">{choices[currentType].title}</p>
							</div>
						</Radio>
					{/each}
				</Dropdown>
			{/if}
			{#if requestCodeTypes.includes(type)}
				<div class="h-[48px]">
					<Button
						title="Resend code"
						class="variant-ghost-secondary h-[48px] w-[48px] px-2"
						onclick={async () => {
							requested = true;
							await requestNewCode(type, true);
						}}
						submitted={requested}
					>
						<Icon icon="tabler:reload" class="text-[20px]" />
					</Button>
				</div>
			{/if}
		</div>
		{#if $errors._errors && Array.isArray($errors._errors)}
			<ul class="whitespace-normal text-[14px] text-error-400 text-center">
				{#each $errors._errors as error (error)}
					<li>{error}</li>
				{/each}
			</ul>
		{/if}
		<form
			class="space-y-6"
			autocomplete="off"
			onsubmit={confirmCode}
		>
			<Input field="code" required bind:value={$form.code} bind:ref={codeInput}
				>Code</Input
			>
			{#if $errors.code && Array.isArray($errors.code)}
				<ul class="whitespace-normal text-[14px] mt-2 text-error-400">
					{#each $errors.code as error (error)}
						<li>{error}</li>
					{/each}
				</ul>
			{/if}
			<div class="flex justify-between">
				<Button
					class="variant-ringed-surface hover:bg-surface-600"
					value="Cancel"
					type="button"
					onclick={cancel}>Cancel</Button
				>
				<Button type="submit" class="variant-filled-primary" {submitted}
					>Submit</Button
				>
			</div>
		</form>
	{/if}
</div>

